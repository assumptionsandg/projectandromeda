{
  "_from": "socketio-jwt@^4.5.0",
  "_id": "socketio-jwt@4.5.0",
  "_inBundle": false,
  "_integrity": "sha1-6riUwlk9+jWGIrltebjBiI12p88=",
  "_location": "/socketio-jwt",
  "_phantomChildren": {
    "jws": "3.2.2"
  },
  "_requested": {
    "escapedName": "socketio-jwt",
    "fetchSpec": "^4.5.0",
    "name": "socketio-jwt",
    "raw": "socketio-jwt@^4.5.0",
    "rawSpec": "^4.5.0",
    "registry": true,
    "saveSpec": null,
    "type": "range"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/socketio-jwt/-/socketio-jwt-4.5.0.tgz",
  "_shasum": "eab894c2593dfa358622b96d79b8c1888d76a7cf",
  "_spec": "socketio-jwt@^4.5.0",
  "_where": "/home/assumptions/Documents/Legacy Project Andromeda/Project Andromeda (OOP)",
  "author": {
    "email": "jfromaniello@gmail.com",
    "name": "Jos√© F. Romaniello",
    "url": "http://joseoncode.com"
  },
  "bugs": {
    "url": "https://github.com/auth0/socketio-jwt/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "jsonwebtoken": "^5.0.0",
    "xtend": "~2.1.2"
  },
  "deprecated": false,
  "description": "authenticate socket.io connections using JWTs",
  "devDependencies": {
    "body-parser": "~1.13.3",
    "express": "~4.10.6",
    "mocha": "~1.17.0",
    "passport-local": "~0.1.6",
    "request": "~2.19.0",
    "serve-static": "^1.7.1",
    "server-destroy": "~1.0.1",
    "should": "~1.2.2",
    "socket.io": "^1.0.4",
    "socket.io-client": "^1.0.4"
  },
  "homepage": "https://github.com/auth0/socketio-jwt#readme",
  "keywords": [
    "jwt",
    "socket",
    "socket.io"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "name": "socketio-jwt",
  "optionalDependencies": {},
  "readme": "[![Build Status](https://travis-ci.org/auth0/socketio-jwt.svg)](https://travis-ci.org/auth0/socketio-jwt)\n\nAuthenticate socket.io incoming connections with JWTs. This is useful if you are build a single page application and you are not using cookies as explained in this blog post: [Cookies vs Tokens. Getting auth right with Angular.JS](http://blog.auth0.com/2014/01/07/angularjs-authentication-with-cookies-vs-token/).\n\n## Installation\n\n```\nnpm install socketio-jwt\n```\n\n## Example usage\n\n```javascript\n// set authorization for socket.io\nio.sockets\n  .on('connection', socketioJwt.authorize({\n    secret: 'your secret or public key',\n    timeout: 15000 // 15 seconds to send the authentication message\n  })).on('authenticated', function(socket) {\n    //this socket is authenticated, we are good to handle more events from it.\n    console.log('hello! ' + socket.decoded_token.name);\n  });\n```\n\n**Note:** If you are using a base64-encoded secret (e.g. your Auth0 secret key), you need to convert it to a Buffer: `Buffer('your secret key', 'base64')`\n\n__Client side__:\n\n```javascript\nvar socket = io.connect('http://localhost:9000');\nsocket.on('connect', function (socket) {\n  socket\n    .on('authenticated', function () {\n      //do other things\n    })\n    .emit('authenticate', {token: jwt}); //send the jwt\n});\n```\n\n## One roundtrip\n\nThe previous approach uses a second roundtrip to send the jwt, there is a way you can authenticate on the handshake by sending the JWT as a query string, the caveat is that intermediary HTTP servers can log the url.\n\n```javascript\nvar io            = require(\"socket.io\")(server);\nvar socketioJwt   = require(\"socketio-jwt\");\n\n//// With socket.io < 1.0 ////\nio.set('authorization', socketioJwt.authorize({\n  secret: 'your secret or public key',\n  handshake: true\n}));\n//////////////////////////////\n\n//// With socket.io >= 1.0 ////\nio.use(socketioJwt.authorize({\n  secret: 'your secret or public key',\n  handshake: true\n}));\n///////////////////////////////\n\nio.on('connection', function (socket) {\n  // in socket.io < 1.0\n  console.log('hello!', socket.handshake.decoded_token.name);\n\n  // in socket.io 1.0\n  console.log('hello! ', socket.decoded_token.name);\n})\n```\n\nFor more validation options see [auth0/jsonwebtoken](https://github.com/auth0/node-jsonwebtoken).\n\n__Client side__:\n\nAppend the jwt token using query string:\n\n```javascript\nvar socket = io.connect('http://localhost:9000', {\n  'query': 'token=' + your_jwt\n});\n```\n\n## Handling token expiration\n\n__Server side__:\n\nWhen you sign the token with an expiration time:\n\n```javascript\nvar token = jwt.sign(user_profile, jwt_secret, {expiresInMinutes: 60});\n```\n\nYour client-side code should handle it as below.\n\n__Client side__:\n\n```javascript\nsocket.on(\"error\", function(error) {\n  if (error.type == \"UnauthorizedError\" || error.code == \"invalid_token\") {\n    // redirect user to login page perhaps?\n    console.log(\"User's token has expired\");\n  }\n});\n```\n\n## Handling invalid token\n\nToken sent by client is invalid.\n\n__Server side__:\n\nNo further configuration needed.\n\n__Client side__:\n\nAdd a callback client-side to execute socket disconnect server-side.\n\n```javascript\nsocket.on(\"unauthorized\", function(error, callback) {\n  if (error.data.type == \"UnauthorizedError\" || error.data.code == \"invalid_token\") {\n    // redirect user to login page perhaps or execute callback:\n    callback();\n    console.log(\"User's token has expired\");\n  }\n});\n```\n\n__Server side__:\n\nTo disconnect socket server-side without client-side callback:\n\n```javascript\nio.sockets.on('connection', socketioJwt.authorize({\n  secret: 'secret goes here',\n  // No client-side callback, terminate connection server-side\n  callback: false \n}))\n```\n\n__Client side__:\n\nNothing needs to be changed client-side if callback is false.\n\n__Server side__:\n\nTo disconnect socket server-side while giving client-side 15 seconds to execute callback:\n\n```javascript\nio.sockets.on('connection', socketioJwt.authorize({\n  secret: 'secret goes here',\n  // Delay server-side socket disconnect to wait for client-side callback\n  callback: 15000 \n}))\n```\n\nYour client-side code should handle it as below.\n\n__Client side__:\n\n```javascript\nsocket.on(\"unauthorized\", function(error, callback) {\n  if (error.data.type == \"UnauthorizedError\" || error.data.code == \"invalid_token\") {\n    // redirect user to login page perhaps or execute callback:\n    callback();\n    console.log(\"User's token has expired\");\n  }\n});\n```\n\n## Getting the secret dynamically\nYou can pass a function instead of an string when configuring secret.\nThis function receives the request, the decoded token and a callback. This\nway, you are allowed to use a different secret based on the request and / or\nthe provided token.\n\n__Server side__:\n\n```javascript\nvar SECRETS = {\n  'user1': 'secret 1',\n  'user2': 'secret 2'\n}\n\nio.use(socketioJwt.authorize({\n  secret: function(request, decodedToken, callback) {\n    // SECRETS[decodedToken.userId] will be used a a secret or\n    // public key for connection user.\n\n    callback(null, SECRETS[decodedToken.userId]);\n  },\n  handshake: false\n}));\n\n```\n\n## Contribute\n\nYou are always welcome to open an issue or provide a pull-request!\n\nAlso check out the unit tests:\n```bash\nnpm test\n```\n\n## Issue Reporting\n\nIf you have found a bug or if you have a feature request, please report them at this repository issues section. Please do not report security vulnerabilities on the public GitHub issue tracker. The [Responsible Disclosure Program](https://auth0.com/whitehat) details the procedure for disclosing security issues.\n\n## Author\n\n[Auth0](auth0.com)\n\n## License\n\nThis project is licensed under the MIT license. See the [LICENSE](LICENSE) file for more info.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/auth0/socketio-jwt.git"
  },
  "scripts": {
    "test": "mocha"
  },
  "version": "4.5.0"
}
